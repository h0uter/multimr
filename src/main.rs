use clap::Parser;
use color_eyre::Result;
use crossterm::event::{self, Event, KeyCode, KeyEvent, KeyEventKind, KeyModifiers};
use ratatui::buffer::Buffer;
use ratatui::layout::{Constraint, Layout, Rect};
use ratatui::style::{Color, Style};
use ratatui::widgets::{Block, List, ListItem, Paragraph, Widget};
use ratatui::{DefaultTerminal, Frame, style::Stylize, text::Line};
use serde::Deserialize;
use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::PathBuf;

const CONFIG_FILE: &str = "multimr.toml";
const DEFAULT_BRANCHES: [&str; 2] = ["main", "master"];

/// CLI arguments
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// Run in dry-run mode (do not actually create MRs)
    #[arg(long)]
    dry_run: bool,
}

fn main() -> color_eyre::Result<()> {
    let cli = Cli::parse();

    ensure_glab_installed();

    // The interactive TUI app
    color_eyre::install()?;
    let terminal = ratatui::init();
    let app = App::new(cli.dry_run);
    let app = app.run(terminal)?;
    ratatui::restore();

    if !app.user_input_completed {
        // If the user exited early, we just exit without doing anything
        println!("Exiting without creating merge requests.");
        return Ok(());
    }

    run_commands(app);

    Ok(())
}

fn run_commands(app: App) {
    // Running the commands generated by the app
    println!("Multi MR will now create merge requests for the following repositories:");
    for dir_index in &app.selected_repos {
        println!(" - {}", app.dirs[*dir_index]);
    }

    for dir_index in app.selected_repos {
        let dir = app.dirs[dir_index].clone();
        std::env::set_current_dir(app.cfg.working_dir.join(&dir))
            .unwrap_or_else(|_| panic!("Failed to change directory to: {}", dir));

        let cmd = app.mr.as_ref().expect("somehow no mr specified").create();

        if app.dry_run {
            app.mr
                .as_ref()
                .expect("somehow no mr specified")
                .dry_run(cmd);
        } else {
            app.mr.as_ref().expect("somehow no mr specified").run(cmd);
        }
    }
}

#[derive(Debug, Default)]
enum Screen {
    #[default]
    RepoSelection,
    CreateMR,
    ReviewerSelection,
    Finalize,
}

impl Screen {
    fn help(&self) -> &'static str {
        match self {
            Screen::RepoSelection => "↑/↓/j/k: Move  Space: Select  Enter: Next  q/Esc: Quit",
            Screen::CreateMR => "Tab: Switch field  ↑/↓/j/k: Select Label  Enter: Next  Esc: Back",
            Screen::ReviewerSelection => "↑/↓/j/k: Move   Space:  Select  Enter: Next  Esc: Back",
            Screen::Finalize => "y/Enter: Confirm  n/Esc: Back",
        }
    }

    fn title(&self) -> &'static str {
        match self {
            Screen::RepoSelection => "Select Repos",
            Screen::CreateMR => "Describe",
            Screen::ReviewerSelection => "Add Reviewers",
            Screen::Finalize => "Finalize",
        }
    }
}

#[derive(Debug, Default)]
pub struct Config {
    pub working_dir: PathBuf,
    pub reviewers: Vec<String>,
    pub labels: HashMap<String, String>,
    pub assignee: String,
}

/// The main application which holds the state and logic of the application.
#[derive(Debug, Default)]
pub struct App {
    /// Is the application running?
    running: bool,
    /// List of directories in the current working directory.
    dirs: Vec<String>,
    /// Indices of selected directories
    selected_repos: HashSet<usize>,
    /// Currently highlighted directory index
    selected_index: usize,
    screen: Screen,
    /// For CreateMR screen
    mr_title: String,
    mr_description: String,
    input_focus: InputFocus,
    /// Indices of selected reviewers
    selected_reviewers: HashSet<usize>,
    /// Currently highlighted reviewer index
    reviewer_index: usize,
    selected_label: usize,
    cfg: Config,
    dry_run: bool,
    mr: Option<MergeRequest>,
    user_input_completed: bool,
}

#[derive(Debug, Default, PartialEq, Eq)]
enum InputFocus {
    #[default]
    Label,
    Title,
    Description,
}

impl App {
    pub fn new(dry_run: bool) -> Self {
        let mut app = Self {
            selected_label: 0,
            selected_index: 0,
            dry_run,
            ..Default::default()
        };
        // Load reviewers from reviewers.toml
        let cfg = load_config_from_toml();
        app.cfg = cfg;

        // Populate dirs with all directories in the current working directory
        if let Ok(entries) = fs::read_dir(&app.cfg.working_dir) {
            app.dirs = entries
                .filter_map(|entry| entry.ok())
                .filter_map(|entry| {
                    let path = entry.path();
                    if path.is_dir() {
                        path.file_name().map(|n| n.to_string_lossy().to_string())
                    } else {
                        None
                    }
                })
                .collect();
        }
        app
    }

    pub fn new_with_dry_run(dry_run: bool) -> Self {
        let mut app = Self {
            selected_label: 0,
            selected_index: 0,
            dry_run,
            ..Default::default()
        };
        // Load reviewers from reviewers.toml
        let cfg = load_config_from_toml();
        app.cfg = cfg;

        // Populate dirs with all directories in the current working directory
        if let Ok(entries) = fs::read_dir(&app.cfg.working_dir) {
            app.dirs = entries
                .filter_map(|entry| entry.ok())
                .filter_map(|entry| {
                    let path = entry.path();
                    if path.is_dir() {
                        path.file_name().map(|n| n.to_string_lossy().to_string())
                    } else {
                        None
                    }
                })
                .collect();
        }
        app
    }

    /// Run the application's main loop.
    pub fn run(mut self, mut terminal: DefaultTerminal) -> Result<Self> {
        self.running = true;
        while self.running {
            terminal.draw(|frame| self.render(frame))?;
            self.handle_crossterm_events()?;
        }
        Ok(self)
    }

    /// Renders the user interface.
    fn render(&mut self, frame: &mut Frame) {
        // Split the screen: main box + help footer at the bottom
        let [window, footer] = Layout::vertical([
            Constraint::Min(0),    // main area for the box
            Constraint::Length(1), // footer (help)
        ])
        .areas(frame.area());

        // Outer block for the whole screen (except help)
        let title = Line::from(format!("Multi MR - {}", self.screen.title()))
            .bold()
            .blue()
            .centered();
        let outer_block = Block::bordered().title(title);

        // Layout inside the box: dirs, title input, desc input, label select
        let inner_area = outer_block.inner(window);

        match self.screen {
            Screen::RepoSelection => self.render_repo_selection(inner_area, frame.buffer_mut()),
            Screen::CreateMR => self.render_create_mr(inner_area, frame.buffer_mut()),
            Screen::ReviewerSelection => {
                self.render_reviewer_selection(inner_area, frame.buffer_mut())
            }
            Screen::Finalize => self.render_overview(inner_area, frame.buffer_mut()),
        }

        outer_block.render(window, frame.buffer_mut());
        Paragraph::new(self.screen.help())
            .centered()
            .style(Style::default().fg(Color::DarkGray))
            .render(footer, frame.buffer_mut());
    }

    fn render_repo_selection(&mut self, window: Rect, buf: &mut Buffer) {
        let [repo_list_area, dir_info_area] = Layout::vertical([
            Constraint::Min(3),
            Constraint::Length(1), // for directory info
        ])
        .areas(window);

        let repos: Vec<ListItem> = self
            .dirs
            .iter()
            .enumerate()
            .map(|(i, d)| {
                let line = if self.selected_repos.contains(&i) {
                    format!("[x] {}", d)
                } else {
                    format!("[ ] {}", d)
                };
                let mut item = ListItem::new(line);
                if i == self.selected_index {
                    item = item.style(Style::default().fg(Color::Yellow).bg(Color::Blue));
                }
                item
            })
            .collect();

        List::new(repos).render(repo_list_area, buf);

        Paragraph::new(format!(
            "Current directory: {} (Selected: {})",
            self.cfg.working_dir.display(),
            self.selected_repos.len()
        ))
        .centered()
        .render(dir_info_area, buf);
    }

    fn render_create_mr(&mut self, window: Rect, buf: &mut Buffer) {
        let [
            dir_area,
            title_input_area,
            description_input_area,
            label_input_area,
        ] = Layout::vertical([
            Constraint::Min(3),
            Constraint::Length(3),
            Constraint::Length(3),
            Constraint::Length(5), // label box
        ])
        .areas(window);

        let selected_dirs: Vec<&String> = self
            .selected_repos
            .iter()
            .copied()
            .filter_map(|i| self.dirs.get(i))
            .collect();

        let dirs_text = if selected_dirs.is_empty() {
            "No repositories selected".to_string()
        } else {
            selected_dirs
                .iter()
                .map(|s| s.as_str())
                .collect::<Vec<_>>()
                .join("\n")
        };

        Paragraph::new(format!("Repositories:\n{}", dirs_text)).render(dir_area, buf);

        Paragraph::new(self.mr_title.as_str())
            .style(if self.input_focus == InputFocus::Title {
                Style::default().bg(Color::Blue).fg(Color::White)
            } else {
                Style::default()
            })
            .block(Block::bordered().title("Title"))
            .render(title_input_area, buf);

        Paragraph::new(self.mr_description.as_str())
            .style(if self.input_focus == InputFocus::Description {
                Style::default().bg(Color::Blue).fg(Color::White)
            } else {
                Style::default()
            })
            .block(Block::bordered().title("Description"))
            .render(description_input_area, buf);

        // Label selection box
        let label_items: Vec<ListItem> = self
            .cfg
            .labels
            .iter()
            .enumerate()
            .map(|(i, (k, v))| {
                let marker = if i == self.selected_label {
                    "(x)"
                } else {
                    "( )"
                };
                let mut item = ListItem::new(format!("{} {}: {}", marker, k, v));
                if self.input_focus == InputFocus::Label && i == self.selected_label {
                    item = item.style(Style::default().fg(Color::Yellow).bg(Color::Blue));
                } else if i == self.selected_label {
                    item = item.style(Style::default().fg(Color::Yellow));
                }
                item
            })
            .collect();

        List::new(label_items)
            .block(Block::bordered().title("Gitlab Label"))
            .render(label_input_area, buf);
    }

    fn render_reviewer_selection(&mut self, window: Rect, buf: &mut Buffer) {
        let [list_area] = Layout::vertical([Constraint::Min(1)]).areas(window);

        let items: Vec<ListItem> = self
            .cfg
            .reviewers
            .iter()
            .enumerate()
            .map(|(i, r)| {
                let line = if self.selected_reviewers.contains(&i) {
                    format!("[x] {}", r)
                } else {
                    format!("[ ] {}", r)
                };
                let mut item = ListItem::new(line);
                if i == self.reviewer_index {
                    item = item.style(Style::default().fg(Color::Yellow).bg(Color::Blue));
                }
                item
            })
            .collect();

        List::new(items).render(list_area, buf);
    }

    fn render_overview(&mut self, window: Rect, buf: &mut Buffer) {
        let selected_dirs: Vec<&String> = self
            .selected_repos
            .iter()
            .copied()
            .filter_map(|i| self.dirs.get(i))
            .collect();
        let selected_reviewers: Vec<&String> = self
            .selected_reviewers
            .iter()
            .copied()
            .filter_map(|i| self.cfg.reviewers.get(i))
            .collect();

        let dirs_text = if selected_dirs.is_empty() {
            "No repositories selected".to_string()
        } else {
            selected_dirs
                .iter()
                .map(|s| s.as_str())
                .collect::<Vec<_>>()
                .join(", ")
        };

        let reviewers_text = if selected_reviewers.is_empty() {
            "No reviewers selected".to_string()
        } else {
            selected_reviewers
                .iter()
                .map(|s| s.as_str())
                .collect::<Vec<_>>()
                .join(", ")
        };

        let [overview_area] = Layout::vertical([Constraint::Min(1)]).areas(window);

        Paragraph::new(format!(
            "Overview\n\nRepositories: {}\nTitle: {}\nDescription: {}\nReviewers: {}\n\nPress 'y' to confirm, 'n' to go back.",
            dirs_text, self.mr_title, self.mr_description, reviewers_text
        )).render(overview_area, buf);
    }

    /// Reads the crossterm events and updates the state of [`App`].
    ///
    /// If your application needs to perform work in between handling events, you can use the
    /// [`event::poll`] function to check if there are any events available with a timeout.
    fn handle_crossterm_events(&mut self) -> Result<()> {
        match event::read()? {
            // it's important to check KeyEventKind::Press to avoid handling key release events
            Event::Key(key) if key.kind == KeyEventKind::Press => self.on_key_event(key),
            Event::Mouse(_) => {}
            Event::Resize(_, _) => {}
            _ => {}
        }
        Ok(())
    }

    /// Handles the key events and updates the state of [`App`].
    fn on_key_event(&mut self, key: KeyEvent) {
        // Handle global key events first
        match key.code {
            KeyCode::Char('c') | KeyCode::Char('C') => {
                if key.modifiers == KeyModifiers::CONTROL {
                    self.quit();
                }
            }
            _ => {}
        }

        match self.screen {
            Screen::RepoSelection => self.on_key_event_selection(key),
            Screen::CreateMR => self.on_key_event_create_mr(key),
            Screen::ReviewerSelection => self.on_key_event_select_reviewers(key),
            Screen::Finalize => self.on_key_event_overview(key),
        }
    }

    fn on_key_event_selection(&mut self, key: KeyEvent) {
        match key.code {
            KeyCode::Esc | KeyCode::Char('q') => {
                self.quit();
            }
            KeyCode::Down | KeyCode::Char('j') => {
                if !self.dirs.is_empty() {
                    self.selected_index = (self.selected_index + 1) % self.dirs.len();
                }
            }
            KeyCode::Up | KeyCode::Char('k') => {
                if !self.dirs.is_empty() {
                    if self.selected_index == 0 {
                        self.selected_index = self.dirs.len() - 1;
                    } else {
                        self.selected_index -= 1;
                    }
                }
            }
            KeyCode::Char(' ') => {
                if self.selected_repos.contains(&self.selected_index) {
                    self.selected_repos.remove(&self.selected_index);
                } else {
                    self.selected_repos.insert(self.selected_index);
                }
            }
            KeyCode::Enter => {
                if !self.selected_repos.is_empty() {
                    self.screen = Screen::CreateMR;
                }
            }
            _ => {}
        }
    }

    fn on_key_event_create_mr(&mut self, key: KeyEvent) {
        match key.code {
            KeyCode::Tab => {
                self.input_focus = match self.input_focus {
                    InputFocus::Title => InputFocus::Description,
                    InputFocus::Description => InputFocus::Label,
                    InputFocus::Label => InputFocus::Title,
                };
            }
            KeyCode::Backspace => match self.input_focus {
                InputFocus::Title => {
                    self.mr_title.pop();
                }
                InputFocus::Description => {
                    self.mr_description.pop();
                }
                InputFocus::Label => {}
            },
            KeyCode::Char(c) => match self.input_focus {
                InputFocus::Title => self.mr_title.push(c),
                InputFocus::Description => self.mr_description.push(c),
                InputFocus::Label => match c {
                    'j' => {
                        if !self.cfg.labels.is_empty() {
                            let idx = self.selected_label;
                            self.selected_label = (idx + 1) % self.cfg.labels.len();
                        }
                    }
                    'k' => {
                        if !self.cfg.labels.is_empty() {
                            let idx = self.selected_label;
                            self.selected_label = if idx == 0 {
                                self.cfg.labels.len() - 1
                            } else {
                                idx - 1
                            };
                        }
                    }
                    _ => {}
                },
            },
            KeyCode::Down => {
                if self.input_focus == InputFocus::Label && !self.cfg.labels.is_empty() {
                    let idx = self.selected_label;
                    self.selected_label = (idx + 1) % self.cfg.labels.len();
                }
            }
            KeyCode::Up => {
                if self.input_focus == InputFocus::Label && !self.cfg.labels.is_empty() {
                    let idx = self.selected_label;
                    self.selected_label = if idx == 0 {
                        self.cfg.labels.len() - 1
                    } else {
                        idx - 1
                    };
                }
            }
            KeyCode::Enter => {
                self.screen = Screen::ReviewerSelection;
            }
            KeyCode::Esc => {
                self.screen = Screen::RepoSelection;
            }
            _ => {}
        }
    }

    fn on_key_event_select_reviewers(&mut self, key: KeyEvent) {
        match key.code {
            KeyCode::Down | KeyCode::Char('j') => {
                if !self.cfg.reviewers.is_empty() {
                    self.reviewer_index = (self.reviewer_index + 1) % self.cfg.reviewers.len();
                }
            }
            KeyCode::Up | KeyCode::Char('h') => {
                if !self.cfg.reviewers.is_empty() {
                    if self.reviewer_index == 0 {
                        self.reviewer_index = self.cfg.reviewers.len() - 1;
                    } else {
                        self.reviewer_index -= 1;
                    }
                }
            }
            KeyCode::Char(' ') => {
                if self.selected_reviewers.contains(&self.reviewer_index) {
                    self.selected_reviewers.remove(&self.reviewer_index);
                } else {
                    self.selected_reviewers.insert(self.reviewer_index);
                }
            }
            KeyCode::Enter => {
                self.screen = Screen::Finalize;
            }
            KeyCode::Esc => {
                self.screen = Screen::CreateMR;
            }
            _ => {}
        }
    }

    fn on_key_event_overview(&mut self, key: KeyEvent) {
        match key.code {
            KeyCode::Char('y') | KeyCode::Enter => {
                self.mr = Some(MergeRequest {
                    title: self.mr_title.clone(),
                    description: self.mr_description.clone(),
                    reviewers: self
                        .selected_reviewers
                        .iter()
                        .map(|&i| self.cfg.reviewers[i].clone())
                        .collect(),
                    labels: self
                        .cfg
                        .labels
                        .keys()
                        .nth(self.selected_label)
                        .map(|k| vec![k.clone()])
                        .unwrap_or_default(),
                    draft: false, // TODO: Add a way to mark as draft
                    assignee: self.cfg.assignee.clone(),
                });

                self.quit_completed();
            }
            KeyCode::Char('n') | KeyCode::Esc => {
                self.screen = Screen::ReviewerSelection;
            }
            _ => {}
        }
    }

    /// Set running to false to quit the application.
    fn quit(&mut self) {
        self.running = false;
    }

    fn quit_completed(&mut self) {
        self.user_input_completed = true;
        self.running = false;
    }
}

#[derive(Debug, Clone)]
pub struct MergeRequest {
    title: String,
    description: String,
    reviewers: Vec<String>,
    labels: Vec<String>,
    draft: bool,
    assignee: String,
}

impl MergeRequest {
    // Placeholder for actual MR creation logic
    fn dummy_create(&mut self) -> std::process::Command {
        let mut cmd = std::process::Command::new("sh");
        cmd.arg("-c").arg(format!(
            "terminal-notifier -sound default -title 'Created MR: {}' -message '{}'",
            self.title, self.description,
        ));

        cmd
    }

    fn create(&self) -> std::process::Command {
        // Create the merge request using glab CLI
        let mut cmd = std::process::Command::new("glab");
        cmd.arg("mr")
            .arg("create")
            .arg("--assignee")
            .arg(&self.assignee);

        if !self.reviewers.is_empty() {
            for reviewer in &self.reviewers {
                cmd.arg("--reviewer").arg(reviewer);
            }
        }

        if !self.labels.is_empty() {
            for label in &self.labels {
                cmd.arg("--label").arg(label);
            }
        }

        let current_branch = get_current_branch();

        cmd.arg("--title").arg(&self.title);
        cmd.arg("--description").arg(&self.description);

        if DEFAULT_BRANCHES.contains(&current_branch.as_str()) {
            // If the current branch is main or master, create a new branch

            println!();

            std::process::Command::new("git")
                .arg("switch")
                .arg("-c")
                .arg(self.title.replace(' ', "-"))
                .status()
                .expect("Failed to create new branch");

            println!();

            std::process::Command::new("git")
                .arg("add")
                .arg(".")
                .status()
                .expect("Failed to add changes");

            std::process::Command::new("git")
                .arg("commit")
                .arg("-am")
                .arg(&self.title)
                .status()
                .or_else(|_e| -> Result<std::process::ExitStatus, std::io::Error> {
                    // Retry once if adding and committing fails, this might happen if the pre-commit hook formats the code
                    // TODO: test this.
                    std::process::Command::new("git")
                        .arg("add")
                        .arg(".")
                        .status()
                        .expect("Failed to add changes Second attempt");

                    println!();

                    let status = std::process::Command::new("git")
                        .arg("commit")
                        .arg("-am")
                        .arg(&self.title)
                        .status()
                        .expect("Failed to commit changes second attempt");

                    Ok(status)
                })
                .expect("Failed to commit changes twice.");

            // TODO: add retry for when pre-commit hook makes some formatting changes

            cmd.arg("--push");
        } else {
            // If not, just use the current branch
            cmd.arg("--yes");
        }

        cmd
    }

    fn run(&self, mut cmd: std::process::Command) {
        let status = cmd.status().expect("Failed to execute command");
        if !status.success() {
            eprintln!("Failed to create merge request: {:?}", status);
        } else {
            println!("Merge request created successfully.");
        }
    }

    fn dry_run(&self, cmd: std::process::Command) {
        println!(
            "Current directory: {}",
            std::env::current_dir().unwrap().display()
        );

        println!("Dry run command: {:?}", cmd);
    }
}

fn get_current_branch() -> String {
    let current_branch_output = std::process::Command::new("git")
        .arg("branch")
        .arg("--show-current")
        .output()
        .expect("Failed to get current branch");

    String::from_utf8_lossy(&current_branch_output.stdout)
        .trim()
        .to_string()
}

fn load_config_from_toml() -> Config {
    let content = std::fs::read_to_string(CONFIG_FILE).unwrap_or_default();

    #[derive(Deserialize)]
    struct ConfigToml {
        reviewers: Option<Vec<String>>,
        labels: Option<HashMap<String, String>>,
        working_dir: Option<String>,
        assignee: Option<String>,
    }

    // if the entire parsing fails return a config with None values
    let parsed: ConfigToml = toml::from_str(&content).unwrap_or(ConfigToml {
        reviewers: None,
        labels: None,
        working_dir: None,
        assignee: None,
    });

    // check if a root is specified in toml, if not use current directory
    let working_dir_str = parsed.working_dir.unwrap_or(".".to_string());

    // there is a root, now create a PathBuf
    let working_dir = if working_dir_str.starts_with('/') || working_dir_str.starts_with('\\') {
        // root // absolute path
        PathBuf::from(&working_dir_str)
            .canonicalize()
            .expect("Failed to resolve absolute path")
    } else {
        // working dir is specified as relative path
        std::env::current_dir()
            .unwrap_or_else(|_| PathBuf::from("."))
            .join(working_dir_str)
            .canonicalize()
            .expect("Failed to resolve relative path")
    };

    // if individual fields fail, we use default values
    Config {
        working_dir,
        reviewers: parsed.reviewers.unwrap_or_default(),
        labels: parsed
            .labels
            .map(|m| m.into_iter().collect())
            .unwrap_or_default(),
        assignee: parsed.assignee.expect("Assignee is required"),
    }
}

fn ensure_glab_installed() {
    if std::process::Command::new("glab")
        .arg("--version")
        .output()
        .is_err()
    {
        eprintln!(
            "[Error] Gitlab CLI `glab` is not installed. Please install it to use this application."
        );
        std::process::exit(1);
    }
}

fn ensure_git_repo() {
    if std::process::Command::new("git")
        .arg("rev-parse")
        .arg("--is-inside-work-tree")
        .output()
        .is_err()
    {
        eprintln!(
            "[Error] This is not a git repository. Please run this application inside a git repository."
        );
        std::process::exit(1);
    }
}

#[cfg(test)]
mod test_main;
